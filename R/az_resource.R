#' Azure resource class
#'
#' Class representing a generic Azure resource.
#'
#' @docType class
#' @section Methods:
#' - `new(...)`: Initialize a new resource object. See 'Initialization' for more details.
#' - `check()`: Check if this resource still exists.
#' - `delete(..., confirm=TRUE, wait=FALSE)`: Delete this resource, after a confirmation check. Optionally wait for the delete to finish.
#' - `update(...)`: Update this resource on the host.
#' - `sync_fields()`: Update the fields in this object with information from the host.
#' - `set_api_version(api_version)`: Set the API version to use when interacting with the host. By default, use the latest API version available.
#' - `do_operation(...)` Carry out an operation. See 'Operations' for more details.
#'
#' @section Initialization:
#' There are multiple ways to initialize a new resource object. You can either retrieve an existing resource, or deploy a new resource on the host. Generally, the easiest way to initialize an object is via the `get_resource`, `create_resource` or `list_resources` methods of the [az_resource_group] class, which will handle the details automatically.
#'
#' To initialize a resource object from scratch, supply the following arguments to `new()`:
#' - `token`: An OAuth 2.0 token, as generated by [get_azure_token].
#' - `subscription`: The subscription ID.
#' - `resource_group`: The resource group.
#'
#' There are also a number of _identifying arguments_ to `new()` that are used to refer to a specific resource:
#' - `id`: The full ID of the resource. This is a string of the form `"/subscriptions/{uuid}/resourceGroups/{resource-group-name}/provider/{resource-provider-name}/{resource-path}/{resource-name}"`.
#' - `provider`: The provider of the resource, eg `Microsoft.Compute`.
#' - `path`: The path to the resource, eg `virtualMachines`.
#' - `type`: The combination of provider and path, eg `Microsoft.Compute/virtualMachines`.
#' - `name`: The name of the resource instance, eg `myWindowsVM`.
#'
#' Providing the `id` argument will fill in the values for all the other arguments. Similarly, providing the `type` argument will fill in the values for `provider` and `path`. Unless you provide `id`, you must also provide `name`.
#'
#' If you provide only these identifying arguments to `new()`, it is assumed that you want to retrieve an existing resource. Passing any further (named) arguments will create a new resource, with the supplied arguments as parameters.
#'
#' By default, a freshly initialised object that refers to an existing resource will only contain minimal information. You should call the `sync_fields()` method to update the fields in the object before doing anything with it.
#'
#' @section Operations:
#' The `do_operation()` method allows you to carry out arbitrary operations on the resource. It takes the following arguments:
#' - `http_verb`: The HTTP verb as a string, one of `GET`, `PUT`, `POST`, `DELETE`, `HEAD` or `PATCH`.
#' - `op`: The operation in question, which will be appended to the URL path of the request.
#' - `options`: A named list giving the URL query parameters.
#' - `...`: Other named arguments passed to [call_azure_rm], and then to the appropriate call in httr. In particular, use `body` to supply the body of a request.
#'
#' Consult the Azure documentation for your resource to find out what operations are supported.
#'
#' @seealso
#' [az_resource_group], [call_azure_rm], [call_azure_url],
#' [Resources API reference](https://docs.microsoft.com/en-us/rest/api/resources/resources)
#'
#' @format An R6 object of class `az_resource`.
#' @export
az_resource <- R6::R6Class("az_resource",

public=list(
    subscription=NULL,
    resource_group=NULL,
    type=NULL,
    name=NULL,
    id=NULL,
    identity=NULL,
    kind=NULL,
    location=NULL,
    managed_by=NULL,
    plan=NULL,
    properties=NULL,
    sku=NULL,
    tags=NULL,
    token=NULL,
    is_synced=FALSE,

    # constructor overloads:
    # 1. deploy resource: resgroup, {provider, path}|type, name, ...
    # 2. deploy resource by id: id, ...
    # 3. get from passed-in data: deployed_properties
    # 4. get from host: resgroup, {provider, path}|type, name
    # 5. get from host by id: id
    initialize=function(token, subscription, resource_group, provider, path, type, name, id, ...,
                        deployed_properties=list(), api_version=NULL)
    {
        self$token <- token
        self$subscription <- subscription

        private$init_id_fields(resource_group, provider, path, type, name, id, deployed_properties)

        # by default this is unset at initialisation, for efficiency
        private$api_version <- api_version

        parms <- if(!is_empty(list(...)))
            private$init_and_deploy(...)
        else if(is_empty(deployed_properties))
            private$init_from_host()
        else private$init_from_parms(deployed_properties)

        self$identity <- parms$identity
        self$kind <- parms$kind
        self$location <- parms$location
        self$managed_by <- parms$managedBy
        self$plan <- parms$plan
        self$properties <- parms$properties
        self$sku <- parms$sku
        self$tags <- parms$tags

        private$is_valid <- TRUE
        NULL
    },

    # API versions vary across different providers; find the latest for this resource
    set_api_version=function(api_version=NULL)
    {
        if(!is_empty(api_version))
        {
            private$api_version <- api_version
            return()
        }

        slash <- regexpr("/", self$type)
        provider <- substr(self$type, 1, slash - 1)
        path <- substr(self$type, slash + 1, nchar(self$type))

        op <- construct_path("providers", provider)
        apis <- named_list(call_azure_rm(self$token, self$subscription, op)$resourceTypes, "resourceType")

        names(apis) <- tolower(names(apis))
        private$api_version <- apis[[tolower(path)]]$apiVersions[[1]]
        if(is_empty(private$api_version))
            stop("Unable to retrieve API version for resource '", self$type, "'.", call.=FALSE)

        invisible(private$api_version)
    },

    sync_fields=function(force=FALSE)
    {
        if(force || !self$is_synced)
            self$initialize(self$token, self$subscription, id=self$id)
        invisible(NULL)
    },

    delete=function(..., options=list(), confirm=TRUE, wait=FALSE)
    {
        if(confirm && interactive())
        {
            yn <- readline(paste0("Do you really want to delete resource '", self$type, "/", self$name, "'? (y/N) "))
            if(tolower(substr(yn, 1, 1)) != "y")
                return(invisible(NULL))
        }

        message("Deleting resource '", construct_path(self$type, self$name), "'")
        private$res_op(..., options=options, http_verb="DELETE")

        if(wait)
        {
            for(i in 1:1000)
            {
                status <- httr::status_code(private$res_op(http_status_handler="pass"))
                if(status >= 300)
                    break
                Sys.sleep(5)
            }
            if(status < 300)
                warning("Attempt to delete resource did not succeed", call.=FALSE)
        }

        private$is_valid <- FALSE
        invisible(NULL)
    },

    do_operation=function(http_verb="GET", ..., options=list())
    {
        private$res_op(..., http_verb=http_verb, options=options)
    },

    check=function()
    {
        # HEAD seems to be broken; do a GET and test whether it fails
        res <- try(private$res_op())
        !inherits(res, "try-error")
    },

    update=function(..., options=list())
    {
        parms <- list(...)
        validate_update_parms(names(parms))
        private$res_op(body=parms, options=options, encode="json", http_verb="PATCH")
    },

    print=function(...)
    {
        cat("<Azure resource ", self$type, "/", self$name, ">\n", sep="")
        cat(format_public_fields(self, exclude=c("subscription", "resource_group", "type", "name")))
        cat(format_public_methods(self))
        invisible(NULL)
    }
),

private=list(
    is_valid=NULL,
    api_version=NULL,

    # initialise identifier fields from multiple ways of constructing object
    init_id_fields=function(resource_group, provider, path, type, name, id, parms=list())
    {
        # if these are supplied, use to fill in everything else
        if(!is_empty(parms$id) && !is_empty(parms$type) && !is_empty(parms$name))
        {
            resource_group <- sub("^.+resourceGroups/([^/]+)/.*$", "\\1", parms$id, ignore.case=TRUE)
            type <- parms$type
            name <- parms$name
            id <- parms$id
        }
        else if(!missing(id))
        {
            resource_group <- sub("^.+resourceGroups/([^/]+)/.*$", "\\1", id, ignore.case=TRUE)
            id2 <- sub("^.+providers/", "", id)
            type_delim <- attr(regexpr("^[^/]+/[^/]+/", id2), "match.length")
            type <- substr(id2, 1, type_delim - 1)
            name <- substr(id2, type_delim + 1, nchar(id2))
        }
        else
        {
            if(missing(type))
                type <- construct_path(provider, path)
            id <- construct_path("/subscriptions", self$subscription, "resourceGroups", resource_group,
                                 "providers", type, name)
        }
        self$resource_group <- resource_group
        self$type <- type
        self$name <- name
        self$id <- id
    },

    init_from_parms=function(parms)
    {
        if(!identical(parms, list(NULL)))
            private$validate_response_parms(parms)
        parms
    },

    init_from_host=function()
    {
        res <- private$res_op()
        self$is_synced <- attr(res, "status") < 202
        res
    },

    init_and_deploy=function(...)
    {
        properties <- list(...)

        # check if we were passed a json object
        if(length(properties) == 1 && is.character(properties[[1]]) && jsonlite::validate(properties[[1]]))
            properties <- jsonlite::fromJSON(properties[[1]], simplifyVector=FALSE)

        private$validate_deploy_parms(properties)
        private$res_op(body=properties, encode="json", http_verb="PUT")

        # allow time for provisioning setup, then get properties
        Sys.sleep(1)
        private$init_from_host()
    },

    validate_deploy_parms=function(parms)
    {
        required_names <- character(0)
        optional_names <- c("identity", "kind", "location", "managedBy", "plan", "properties", "sku", "tags")
        validate_object_names(names(parms), required_names, optional_names)
    },

    validate_response_parms=function(parms)
    {
        required_names <- c("id", "name", "type", "location")
        optional_names <- c("identity", "kind", "managedBy", "plan", "properties", "sku", "tags")
        validate_object_names(names(parms), required_names, optional_names)
    },

    validate_update_parms=function(parms)
    {
        required_names <- character(0)
        optional_names <- c("identity", "kind", "location", "managedBy", "plan", "properties", "sku", "tags")
    },

    res_op=function(op="", ...)
    {
        # make sure we have an API to call
        if(is.null(private$api_version))
            self$set_api_version()

        op <- construct_path("resourcegroups", self$resource_group, "providers", self$type, self$name, op)
        call_azure_rm(self$token, self$subscription, op, ..., api_version=private$api_version)
    }
))
